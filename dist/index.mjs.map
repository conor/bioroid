{"version":3,"sources":["../src/vdom.ts","../src/diff.ts","../src/patch.ts","../src/singultus.ts"],"sourcesContent":["import { SingultusElement, SingultusNode, SingultusAttributes, VNode } from './types'\n\nconst SVG_ELEMENTS = new Set([\n  'svg', 'g', 'path', 'circle', 'ellipse', 'line', 'rect', 'polyline', 'polygon',\n  'text', 'tspan', 'textPath', 'marker', 'defs', 'clipPath', 'mask', 'pattern',\n  'image', 'switch', 'foreignObject', 'use', 'symbol', 'linearGradient',\n  'radialGradient', 'stop', 'animate', 'animateTransform', 'animateMotion'\n])\n\nfunction isNode(element: SingultusElement): element is SingultusNode {\n  return Array.isArray(element) && typeof element[0] === 'string'\n}\n\nfunction parseTagName(tag: string): { tagName: string; id?: string; classes: string[] } {\n  const idMatch = tag.match(/#([^.]+)/)\n  const classMatches = tag.match(/\\.([^#.]+)/g)\n  \n  const tagName = tag.replace(/#[^.]*/, '').replace(/\\.[^#]*/g, '') || 'div'\n  const id = idMatch?.[1]\n  const classes = classMatches?.map(c => c.slice(1)) || []\n  \n  return { tagName, id, classes }\n}\n\nexport function createVNode(singultus: SingultusElement, parentIsSvg = false): VNode {\n  if (singultus == null || typeof singultus === 'boolean') {\n    return { type: 'text', text: '' }\n  }\n  \n  if (typeof singultus === 'string' || typeof singultus === 'number') {\n    return { type: 'text', text: String(singultus) }\n  }\n  \n  if (Array.isArray(singultus)) {\n    if (isNode(singultus)) {\n      const [tag, ...rest] = singultus\n      const { tagName, id, classes } = parseTagName(tag)\n      const isSvg = parentIsSvg || SVG_ELEMENTS.has(tagName)\n      \n      let props: SingultusAttributes = {}\n      let children: SingultusElement[] = []\n      \n      // Parse props and children\n      if (rest.length > 0 && typeof rest[0] === 'object' && !Array.isArray(rest[0]) && rest[0] !== null) {\n        props = { ...rest[0] } as SingultusAttributes\n        children = rest.slice(1) as SingultusElement[]\n      } else {\n        children = rest as SingultusElement[]\n      }\n      \n      // Add parsed CSS classes and id to props\n      if (id) props.id = id\n      if (classes.length > 0) {\n        const existingClasses = props.class || props.className || ''\n        const allClasses = existingClasses ? `${classes.join(' ')} ${existingClasses}` : classes.join(' ')\n        props.class = allClasses\n      }\n      \n      // Extract key\n      const key = props['singultus/key']\n      \n      // Create child VNodes\n      const childVNodes: VNode[] = []\n      for (const child of children as SingultusElement[]) {\n        if (child != null) {\n          childVNodes.push(createVNode(child, isSvg))\n        }\n      }\n      \n      return {\n        type: 'element',\n        tag: tagName,\n        props,\n        children: childVNodes,\n        key,\n        isSvg\n      }\n    } else {\n      // Array of elements - create a fragment-like structure\n      const childVNodes: VNode[] = []\n      for (const child of singultus as SingultusElement[]) {\n        if (child != null) {\n          childVNodes.push(createVNode(child, parentIsSvg))\n        }\n      }\n      return {\n        type: 'element',\n        tag: 'fragment',\n        children: childVNodes\n      }\n    }\n  }\n  \n  return { type: 'text', text: String(singultus) }\n}","import { VNode, Patch, PatchOperation } from './types'\n\nexport function diff(oldVNode: VNode | null, newVNode: VNode | null): Patch[] {\n  const patches: Patch[] = []\n  \n  if (!oldVNode && !newVNode) {\n    return patches\n  }\n  \n  if (!oldVNode && newVNode) {\n    patches.push({ type: 'CREATE', vNode: newVNode })\n    return patches\n  }\n  \n  if (oldVNode && !newVNode) {\n    patches.push({ type: 'REMOVE' })\n    return patches\n  }\n  \n  if (oldVNode && newVNode) {\n    // Different node types or tags - replace entirely\n    if (oldVNode.type !== newVNode.type || \n        (oldVNode.type === 'element' && newVNode.type === 'element' && oldVNode.tag !== newVNode.tag)) {\n      patches.push({ type: 'REPLACE', vNode: newVNode })\n      return patches\n    }\n    \n    // Text nodes\n    if (oldVNode.type === 'text' && newVNode.type === 'text') {\n      if (oldVNode.text !== newVNode.text) {\n        patches.push({ type: 'UPDATE', text: oldVNode.text, newText: newVNode.text })\n      }\n      return patches\n    }\n    \n    // Element nodes\n    if (oldVNode.type === 'element' && newVNode.type === 'element') {\n      // Check props\n      if (propsChanged(oldVNode.props, newVNode.props)) {\n        patches.push({ \n          type: 'UPDATE', \n          props: oldVNode.props, \n          newProps: newVNode.props \n        })\n      }\n      \n      // Diff children\n      const childPatches = diffChildren(oldVNode.children || [], newVNode.children || [])\n      if (childPatches.length > 0) {\n        patches.push({ type: 'REORDER', children: childPatches })\n      }\n    }\n  }\n  \n  return patches\n}\n\nfunction propsChanged(oldProps: any = {}, newProps: any = {}): boolean {\n  const oldKeys = Object.keys(oldProps)\n  const newKeys = Object.keys(newProps)\n  \n  if (oldKeys.length !== newKeys.length) return true\n  \n  for (const key of newKeys) {\n    if (oldProps[key] !== newProps[key]) {\n      // Special handling for style objects\n      if (key === 'style' && typeof oldProps[key] === 'object' && typeof newProps[key] === 'object') {\n        if (JSON.stringify(oldProps[key]) !== JSON.stringify(newProps[key])) {\n          return true\n        }\n      } else {\n        return true\n      }\n    }\n  }\n  \n  return false\n}\n\nfunction diffChildren(oldChildren: VNode[], newChildren: VNode[]): PatchOperation[] {\n  const patches: PatchOperation[] = []\n  \n  // Create key maps for efficient lookups\n  const oldKeyMap = new Map<string | number, { node: VNode; index: number }>()\n  const newKeyMap = new Map<string | number, { node: VNode; index: number }>()\n  \n  // Index old children by key\n  oldChildren.forEach((child, index) => {\n    if (child.key != null) {\n      oldKeyMap.set(child.key, { node: child, index })\n    }\n  })\n  \n  // Index new children by key\n  newChildren.forEach((child, index) => {\n    if (child.key != null) {\n      newKeyMap.set(child.key, { node: child, index })\n    }\n  })\n  \n  // Track which old indices have been processed\n  const processedOldIndices = new Set<number>()\n  let oldIndex = 0\n  \n  // Process new children\n  for (let newIndex = 0; newIndex < newChildren.length; newIndex++) {\n    const newChild = newChildren[newIndex]\n    \n    if (newChild.key != null) {\n      // Keyed element\n      const oldEntry = oldKeyMap.get(newChild.key)\n      \n      if (oldEntry) {\n        // Element exists, check if it moved\n        if (oldEntry.index !== newIndex) {\n          patches.push({\n            type: 'MOVE',\n            oldIndex: oldEntry.index,\n            newIndex,\n            vNode: newChild,\n            key: newChild.key\n          })\n        }\n        processedOldIndices.add(oldEntry.index)\n        \n        // Recursively diff the moved/existing element\n        const childPatches = diff(oldEntry.node, newChild)\n        if (childPatches.length > 0) {\n          // Apply child patches to the moved element\n          patches.push({\n            type: 'MOVE',\n            oldIndex: oldEntry.index,\n            newIndex,\n            vNode: newChild,\n            key: newChild.key\n          })\n        }\n      } else {\n        // New keyed element\n        patches.push({\n          type: 'INSERT',\n          newIndex,\n          vNode: newChild,\n          key: newChild.key\n        })\n      }\n    } else {\n      // Non-keyed element - use positional matching\n      while (oldIndex < oldChildren.length && processedOldIndices.has(oldIndex)) {\n        oldIndex++\n      }\n      \n      if (oldIndex < oldChildren.length) {\n        const oldChild = oldChildren[oldIndex]\n        const childPatches = diff(oldChild, newChild)\n        \n        if (childPatches.length > 0) {\n          patches.push({\n            type: 'MOVE',\n            oldIndex,\n            newIndex,\n            vNode: newChild\n          })\n        }\n        \n        processedOldIndices.add(oldIndex)\n        oldIndex++\n      } else {\n        // No more old children - insert new one\n        patches.push({\n          type: 'INSERT',\n          newIndex,\n          vNode: newChild\n        })\n      }\n    }\n  }\n  \n  // Remove old children that weren't processed\n  for (let i = 0; i < oldChildren.length; i++) {\n    if (!processedOldIndices.has(i)) {\n      patches.push({\n        type: 'REMOVE',\n        oldIndex: i\n      })\n    }\n  }\n  \n  return patches\n}","import { VNode, Patch, PatchOperation, SingultusAttributes } from './types'\nimport { diff } from './diff'\n\n// Boolean attributes that should be omitted when false\nconst BOOLEAN_ATTRIBUTES = new Set([\n  'autofocus', 'autoplay', 'async', 'checked', 'controls', 'defer', 'disabled',\n  'hidden', 'loop', 'multiple', 'muted', 'open', 'readonly', 'required',\n  'reversed', 'selected', 'scoped', 'seamless', 'itemScope', 'noValidate',\n  'allowFullscreen', 'formNoValidate', 'default', 'capture', 'autocomplete'\n])\n\n// Properties that should be set as DOM properties rather than attributes\nconst DOM_PROPERTIES = new Set([\n  'value', 'checked', 'selected', 'defaultValue', 'defaultChecked', 'defaultSelected',\n  'innerHTML', 'textContent', 'innerText', 'htmlFor', 'className', 'tabIndex',\n  'contentEditable', 'draggable', 'spellcheck', 'translate'\n])\n\n// SVG elements that require SVG namespace\nconst SVG_ELEMENTS = new Set([\n  'svg', 'g', 'path', 'circle', 'ellipse', 'line', 'rect', 'polyline', 'polygon',\n  'text', 'tspan', 'textPath', 'marker', 'defs', 'clipPath', 'mask', 'pattern',\n  'image', 'switch', 'foreignObject', 'use', 'symbol', 'linearGradient',\n  'radialGradient', 'stop', 'animate', 'animateTransform', 'animateMotion'\n])\n\nfunction setAttributes(element: Element, attrs: SingultusAttributes, isSvg = false): void {\n  for (const [key, value] of Object.entries(attrs)) {\n    if (key === 'style') {\n      if (typeof value === 'string') {\n        element.setAttribute('style', value)\n      } else if (typeof value === 'object' && value !== null) {\n        const htmlElement = element as HTMLElement\n        for (const [prop, val] of Object.entries(value)) {\n          const kebabProp = prop.replace(/[A-Z]/g, letter => `-${letter.toLowerCase()}`)\n          htmlElement.style.setProperty(kebabProp, String(val))\n        }\n      }\n    } else if (key === 'innerHTML') {\n      element.innerHTML = String(value)\n    } else if (key === 'textContent') {\n      element.textContent = String(value)\n    } else if (key === 'on' && typeof value === 'object' && value !== null) {\n      for (const [eventType, handler] of Object.entries(value)) {\n        if (typeof handler === 'function') {\n          element.addEventListener(eventType, handler as EventListener)\n        }\n      }\n    } else if (key.startsWith('singultus/')) {\n      continue\n    } else if (key === 'className' || key === 'class') {\n      if (value) {\n        if (isSvg) {\n          element.setAttribute('class', String(value))\n        } else {\n          (element as HTMLElement).className = String(value)\n        }\n      }\n    } else if (key === 'htmlFor' && element instanceof HTMLLabelElement) {\n      element.htmlFor = String(value)\n    } else if (DOM_PROPERTIES.has(key) && !isSvg) {\n      (element as any)[key] = value\n    } else if (BOOLEAN_ATTRIBUTES.has(key)) {\n      if (value) {\n        element.setAttribute(key, key)\n      } else {\n        element.removeAttribute(key)\n      }\n    } else if (key.startsWith('data-') || key.startsWith('aria-')) {\n      if (value != null) {\n        element.setAttribute(key, String(value))\n      } else {\n        element.removeAttribute(key)\n      }\n    } else {\n      if (value != null) {\n        element.setAttribute(key, String(value))\n      } else {\n        element.removeAttribute(key)\n      }\n    }\n  }\n}\n\nexport function updateAttributes(element: Element, oldProps: SingultusAttributes = {}, newProps: SingultusAttributes = {}, isSvg = false): void {\n  // Special handling for event listeners - always remove old ones first\n  if (oldProps.on && typeof oldProps.on === 'object' && oldProps.on !== null) {\n    for (const [eventType, handler] of Object.entries(oldProps.on as Record<string, EventListener>)) {\n      if (typeof handler === 'function') {\n        element.removeEventListener(eventType, handler)\n      }\n    }\n  }\n  \n  // Remove old attributes/properties\n  for (const key of Object.keys(oldProps)) {\n    if (!(key in newProps)) {\n      if (key === 'style') {\n        element.setAttribute('style', '')\n      } else if (key === 'className' || key === 'class') {\n        if (isSvg) {\n          element.removeAttribute('class')\n        } else {\n          (element as HTMLElement).className = ''\n        }\n      } else if (key === 'on') {\n        // Event listeners already handled above\n        continue\n      } else if (!key.startsWith('singultus/')) {\n        if (DOM_PROPERTIES.has(key) && !isSvg) {\n          (element as any)[key] = ''\n        } else {\n          element.removeAttribute(key)\n        }\n      }\n    }\n  }\n  \n  // Set new attributes/properties\n  setAttributes(element, newProps, isSvg)\n}\n\nexport function createElement(vNode: VNode): Element | Text {\n  if (vNode.type === 'text') {\n    return document.createTextNode(vNode.text || '')\n  }\n  \n  if (vNode.tag === 'fragment') {\n    // For fragments, create a div wrapper to simplify diffing\n    const wrapper = document.createElement('div')\n    wrapper.style.display = 'contents' // CSS to make wrapper invisible\n    if (vNode.children) {\n      for (const child of vNode.children) {\n        wrapper.appendChild(createElement(child))\n      }\n    }\n    return wrapper\n  }\n  \n  const element = vNode.isSvg\n    ? document.createElementNS('http://www.w3.org/2000/svg', vNode.tag!)\n    : document.createElement(vNode.tag!)\n  \n  if (vNode.props) {\n    setAttributes(element, vNode.props, vNode.isSvg)\n  }\n  \n  if (vNode.children) {\n    for (const child of vNode.children) {\n      element.appendChild(createElement(child))\n    }\n  }\n  \n  // Call lifecycle hook\n  if (vNode.props?.['singultus/on-render']) {\n    vNode.props['singultus/on-render'](element)\n  }\n  \n  return element\n}\n\nexport function applyPatches(element: Element, patches: Patch[], vNodeMap = new Map<Element, VNode>()): void {\n  for (const patch of patches) {\n    switch (patch.type) {\n      case 'CREATE':\n        if (patch.vNode) {\n          const newElement = createElement(patch.vNode)\n          element.appendChild(newElement)\n        }\n        break\n        \n      case 'REMOVE':\n        if (element.parentNode) {\n          element.parentNode.removeChild(element)\n        }\n        break\n        \n      case 'REPLACE':\n        if (patch.vNode && element.parentNode) {\n          const newElement = createElement(patch.vNode)\n          element.parentNode.replaceChild(newElement, element)\n        }\n        break\n        \n      case 'UPDATE':\n        if (patch.text !== undefined && patch.newText !== undefined) {\n          // Text node update\n          if (element instanceof Text) {\n            element.textContent = patch.newText\n          }\n        } else if (patch.props && patch.newProps) {\n          // Props update\n          const vNode = vNodeMap.get(element)\n          updateAttributes(element, patch.props, patch.newProps, vNode?.isSvg)\n          \n          // Call lifecycle hook if present\n          if (patch.newProps['singultus/on-render']) {\n            patch.newProps['singultus/on-render'](element)\n          }\n        }\n        break\n        \n      case 'REORDER':\n        if (patch.children) {\n          applyChildPatches(element, patch.children, vNodeMap)\n        }\n        break\n    }\n  }\n}\n\nexport function applyChildPatches(parent: Element, operations: PatchOperation[], vNodeMap: Map<Element, VNode>): void {\n  const children = Array.from(parent.childNodes) as (Element | Text)[]\n  const keyToElement = new Map<string | number, Element | Text>()\n  \n  // Build key map for existing elements\n  children.forEach(child => {\n    if (child instanceof Element) {\n      const vNode = vNodeMap.get(child)\n      if (vNode?.key != null) {\n        keyToElement.set(vNode.key, child)\n      }\n    }\n  })\n  \n  // Apply operations in reverse order to maintain indices\n  for (let i = operations.length - 1; i >= 0; i--) {\n    const op = operations[i]\n    \n    switch (op.type) {\n      case 'INSERT':\n        if (op.vNode && op.newIndex !== undefined) {\n          const newElement = createElement(op.vNode)\n          const referenceNode = children[op.newIndex] || null\n          parent.insertBefore(newElement, referenceNode)\n          \n          // Update vNodeMap\n          vNodeMap.set(newElement as Element, op.vNode)\n        }\n        break\n        \n      case 'MOVE':\n        if (op.oldIndex !== undefined && op.newIndex !== undefined) {\n          const element = children[op.oldIndex]\n          if (element) {\n            // If indices are the same, this is an in-place update\n            if (op.oldIndex !== op.newIndex) {\n              const referenceNode = children[op.newIndex] || null\n              parent.insertBefore(element, referenceNode)\n            }\n            \n            // Update element content if vNode provided\n            if (op.vNode) {\n              if (op.vNode.type === 'text' && element instanceof Text) {\n                // Direct text node update\n                element.textContent = op.vNode.text || ''\n              } else if (op.vNode.type === 'element' && element instanceof Element) {\n                // For element nodes, apply recursive patches\n                const oldVNode = vNodeMap.get(element)\n                if (oldVNode) {\n                  const elementPatches = diff(oldVNode, op.vNode)\n                  if (elementPatches.length > 0) {\n                    applyPatches(element, elementPatches, vNodeMap)\n                  }\n                }\n                vNodeMap.set(element, op.vNode)\n              }\n            }\n          }\n        }\n        break\n        \n      case 'REMOVE':\n        if (op.oldIndex !== undefined) {\n          const element = children[op.oldIndex]\n          if (element && parent.contains(element)) {\n            parent.removeChild(element)\n            if (element instanceof Element) {\n              vNodeMap.delete(element)\n            }\n          }\n        }\n        break\n    }\n  }\n}","import { SingultusElement, SingultusNode, SingultusAttributes, VNode } from './types'\nimport { createVNode } from './vdom'\nimport { diff } from './diff'\nimport { applyPatches, createElement, updateAttributes, applyChildPatches } from './patch'\n\nfunction isNode(element: SingultusElement): element is SingultusNode {\n  return Array.isArray(element) && typeof element[0] === 'string'\n}\n\nfunction parseTagName(tag: string): { tagName: string; id?: string; classes: string[] } {\n  const idMatch = tag.match(/#([^.]+)/)\n  const classMatches = tag.match(/\\.([^#.]+)/g)\n  \n  const tagName = tag.replace(/#[^.]*/, '').replace(/\\.[^#]*/g, '') || 'div'\n  const id = idMatch?.[1]\n  const classes = classMatches?.map(c => c.slice(1)) || []\n  \n  return { tagName, id, classes }\n}\n\n// Boolean attributes that should be omitted when false\nconst BOOLEAN_ATTRIBUTES = new Set([\n  'autofocus', 'autoplay', 'async', 'checked', 'controls', 'defer', 'disabled',\n  'hidden', 'loop', 'multiple', 'muted', 'open', 'readonly', 'required',\n  'reversed', 'selected', 'scoped', 'seamless', 'itemScope', 'noValidate',\n  'allowFullscreen', 'formNoValidate', 'default', 'capture', 'autocomplete'\n])\n\n// Properties that should be set as DOM properties rather than attributes\nconst DOM_PROPERTIES = new Set([\n  'value', 'checked', 'selected', 'defaultValue', 'defaultChecked', 'defaultSelected',\n  'innerHTML', 'textContent', 'innerText', 'htmlFor', 'className', 'tabIndex',\n  'contentEditable', 'draggable', 'spellcheck', 'translate'\n])\n\nfunction setAttributes(element: Element, attrs: SingultusAttributes): void {\n  for (const [key, value] of Object.entries(attrs)) {\n    if (key === 'style') {\n      if (typeof value === 'string') {\n        element.setAttribute('style', value)\n      } else if (typeof value === 'object' && value !== null) {\n        const htmlElement = element as HTMLElement\n        for (const [prop, val] of Object.entries(value)) {\n          // Convert camelCase to kebab-case for CSS properties\n          const kebabProp = prop.replace(/[A-Z]/g, letter => `-${letter.toLowerCase()}`)\n          htmlElement.style.setProperty(kebabProp, String(val))\n        }\n      }\n    } else if (key === 'innerHTML') {\n      element.innerHTML = String(value)\n    } else if (key === 'textContent') {\n      element.textContent = String(value)\n    } else if (key === 'on' && typeof value === 'object' && value !== null) {\n      for (const [eventType, handler] of Object.entries(value)) {\n        if (typeof handler === 'function') {\n          element.addEventListener(eventType, handler as EventListener)\n        }\n      }\n    } else if (key.startsWith('singultus/')) {\n      continue\n    } else if (key === 'className' || key === 'class') {\n      if (value) {\n        element.setAttribute('class', String(value))\n      }\n    } else if (key === 'htmlFor' && element instanceof HTMLLabelElement) {\n      element.htmlFor = String(value)\n    } else if (DOM_PROPERTIES.has(key)) {\n      // Set as DOM property\n      (element as any)[key] = value\n    } else if (BOOLEAN_ATTRIBUTES.has(key)) {\n      // Boolean attributes: set attribute if truthy, remove if falsy\n      if (value) {\n        element.setAttribute(key, key) // HTML5 style: disabled=\"disabled\"\n      } else {\n        element.removeAttribute(key)\n      }\n    } else if (key.startsWith('data-') || key.startsWith('aria-')) {\n      // Data and ARIA attributes: always set as attributes\n      if (value != null) {\n        element.setAttribute(key, String(value))\n      } else {\n        element.removeAttribute(key)\n      }\n    } else {\n      // Regular attributes\n      if (value != null) {\n        element.setAttribute(key, String(value))\n      } else {\n        element.removeAttribute(key)\n      }\n    }\n  }\n}\n\n// SVG elements that require SVG namespace\nconst SVG_ELEMENTS = new Set([\n  'svg', 'g', 'path', 'circle', 'ellipse', 'line', 'rect', 'polyline', 'polygon',\n  'text', 'tspan', 'textPath', 'marker', 'defs', 'clipPath', 'mask', 'pattern',\n  'image', 'switch', 'foreignObject', 'use', 'symbol', 'linearGradient',\n  'radialGradient', 'stop', 'animate', 'animateTransform', 'animateMotion'\n])\n\nfunction createElementLegacy(singultus: SingultusNode): Element {\n  const [tag, ...rest] = singultus\n  const { tagName, id, classes } = parseTagName(tag)\n  \n  // Create element with appropriate namespace\n  const element = SVG_ELEMENTS.has(tagName)\n    ? document.createElementNS('http://www.w3.org/2000/svg', tagName)\n    : document.createElement(tagName)\n  \n  if (id) {\n    element.id = id\n  }\n  \n  if (classes.length > 0) {\n    if (SVG_ELEMENTS.has(tagName)) {\n      element.setAttribute('class', classes.join(' '))\n    } else {\n      (element as HTMLElement).className = classes.join(' ')\n    }\n  }\n  \n  let attrs: SingultusAttributes = {}\n  let children: SingultusElement[] = []\n  \n  if (rest.length > 0 && typeof rest[0] === 'object' && !Array.isArray(rest[0]) && rest[0] !== null) {\n    attrs = rest[0] as SingultusAttributes\n    children = rest.slice(1) as SingultusElement[]\n  } else {\n    children = rest as SingultusElement[]\n  }\n  \n  if (attrs.class || attrs.className) {\n    const existingClasses = element.className ? element.className.split(' ') : []\n    const newClasses = String(attrs.class || attrs.className).split(' ').filter(Boolean)\n    const combinedClasses = [...new Set([...existingClasses, ...newClasses])].join(' ')\n    \n    if (SVG_ELEMENTS.has(tagName)) {\n      element.setAttribute('class', combinedClasses)\n    } else {\n      (element as HTMLElement).className = combinedClasses\n    }\n  }\n  \n  setAttributes(element, attrs)\n  \n  for (const child of children) {\n    if (child != null) {\n      if (isNode(child)) {\n        element.appendChild(createElementLegacy(child))\n      } else if (Array.isArray(child)) {\n        // Handle arrays of children\n        for (const nestedChild of child) {\n          if (nestedChild != null) {\n            if (isNode(nestedChild)) {\n              element.appendChild(createElementLegacy(nestedChild))\n            } else {\n              element.appendChild(document.createTextNode(String(nestedChild)))\n            }\n          }\n        }\n      } else {\n        element.appendChild(document.createTextNode(String(child)))\n      }\n    }\n  }\n  \n  if (attrs['singultus/on-render']) {\n    attrs['singultus/on-render'](element)\n  }\n  \n  return element\n}\n\n// Store the previous virtual DOM for diffing\nconst containerVNodeMap = new WeakMap<Element, VNode>()\nconst containerElementMap = new WeakMap<Element, Map<Element, VNode>>()\n\n// Helper function to map DOM nodes to their corresponding VNodes\nfunction mapElementsToVNodes(element: Element, vNode: VNode, map: Map<Element, VNode>): void {\n  map.set(element, vNode)\n  \n  if (vNode.type === 'element' && vNode.children) {\n    const childNodes = Array.from(element.childNodes)\n    \n    let nodeIndex = 0\n    for (const childVNode of vNode.children) {\n      if (nodeIndex < childNodes.length) {\n        const childNode = childNodes[nodeIndex]\n        \n        if (childVNode.type === 'element' && childNode.nodeType === Node.ELEMENT_NODE) {\n          mapElementsToVNodes(childNode as Element, childVNode, map)\n        }\n        // Note: We can't map text nodes to the Element-keyed map, \n        // but the patch system will handle text updates directly\n        \n        nodeIndex++\n      }\n    }\n  }\n}\n\nexport function render(container: Element, singultus: SingultusElement): void {\n  // Get the previous VNode for this container\n  const oldVNode = containerVNodeMap.get(container)\n  \n  // Create new VNode from current singultus\n  const newVNode = singultus == null ? null : createVNode(singultus)\n  \n  // For the first render, use simple approach and store state\n  if (!oldVNode) {\n    renderSimple(container, singultus)\n    if (newVNode) {\n      containerVNodeMap.set(container, newVNode)\n      // Create element mapping for future diffs\n      const elementMap = new Map<Element, VNode>()\n      if (container.firstElementChild) {\n        mapElementsToVNodes(container.firstElementChild, newVNode, elementMap)\n      }\n      containerElementMap.set(container, elementMap)\n    }\n    return\n  }\n  \n  // Calculate differences\n  const patches = diff(oldVNode, newVNode)\n  \n  if (patches.length === 0) {\n    // No changes needed - KEY OPTIMIZATION\n    return\n  }\n  \n  // Get the existing element mapping\n  const elementMap = containerElementMap.get(container) || new Map<Element, VNode>()\n  \n  // Apply patches based on patch type\n  try {\n    let patchApplied = false\n    \n    for (const patch of patches) {\n      switch (patch.type) {\n        case 'CREATE':\n          // Container was empty, create new content\n          if (patch.vNode) {\n            const newElement = createElement(patch.vNode)\n            container.appendChild(newElement)\n            patchApplied = true\n          }\n          break\n          \n        case 'REMOVE':\n          // Remove all content from container\n          container.innerHTML = ''\n          patchApplied = true\n          break\n          \n        case 'REPLACE':\n          // Replace entire content\n          container.innerHTML = ''\n          if (patch.vNode) {\n            const newElement = createElement(patch.vNode)\n            container.appendChild(newElement)\n            patchApplied = true\n          }\n          break\n          \n        case 'UPDATE':\n          // Update the root element's properties\n          if (container.firstElementChild && patch.props && patch.newProps) {\n            const vNode = elementMap.get(container.firstElementChild)\n            updateAttributes(container.firstElementChild, patch.props, patch.newProps, vNode?.isSvg)\n            if (patch.newProps['singultus/on-render']) {\n              patch.newProps['singultus/on-render'](container.firstElementChild)\n            }\n            patchApplied = true\n          }\n          break\n          \n        case 'REORDER':\n          // Apply child reordering to the root element\n          if (container.firstElementChild && patch.children) {\n            applyChildPatches(container.firstElementChild, patch.children, elementMap)\n            \n            // Call lifecycle hook if present on the new VNode (since the element was updated)\n            if (newVNode?.props?.['singultus/on-render']) {\n              newVNode.props['singultus/on-render'](container.firstElementChild)\n            }\n            \n            patchApplied = true\n          }\n          break\n      }\n    }\n    \n    if (patchApplied) {\n      // Update stored state after successful patch application\n      if (newVNode) {\n        containerVNodeMap.set(container, newVNode)\n        // Update element mapping\n        const newElementMap = new Map<Element, VNode>()\n        if (container.firstElementChild) {\n          mapElementsToVNodes(container.firstElementChild, newVNode, newElementMap)\n        }\n        containerElementMap.set(container, newElementMap)\n      } else {\n        containerVNodeMap.delete(container)\n        containerElementMap.delete(container)\n      }\n    }\n  } catch (error) {\n    // If patch application fails, fall back to simple render\n    console.warn('Patch application failed, falling back to simple render:', error)\n    renderSimple(container, singultus)\n    if (newVNode) {\n      containerVNodeMap.set(container, newVNode)\n      const elementMap = new Map<Element, VNode>()\n      if (container.firstElementChild) {\n        mapElementsToVNodes(container.firstElementChild, newVNode, elementMap)\n      }\n      containerElementMap.set(container, elementMap)\n    } else {\n      containerVNodeMap.delete(container)\n      containerElementMap.delete(container)\n    }\n  }\n}\n\n// Legacy simple render function for backwards compatibility\nexport function renderSimple(container: Element, singultus: SingultusElement): void {\n  container.innerHTML = ''\n  \n  if (singultus == null) {\n    return\n  }\n  \n  if (isNode(singultus)) {\n    container.appendChild(createElementLegacy(singultus))\n  } else if (Array.isArray(singultus)) {\n    for (const child of singultus) {\n      if (child != null) {\n        if (isNode(child)) {\n          container.appendChild(createElementLegacy(child))\n        } else if (Array.isArray(child)) {\n          // Handle nested arrays recursively\n          renderSimple(container, child)\n        } else {\n          container.appendChild(document.createTextNode(String(child)))\n        }\n      }\n    }\n  } else {\n    container.appendChild(document.createTextNode(String(singultus)))\n  }\n}"],"mappings":"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","names":["isNode","parseTagName","BOOLEAN_ATTRIBUTES","DOM_PROPERTIES","setAttributes","SVG_ELEMENTS","elementMap"]}